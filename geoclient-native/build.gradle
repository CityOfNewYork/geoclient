apply plugin: 'c'

model {
  platforms {
    linux_x64 {
       architecture "x86_64"
       operatingSystem "linux"
    }
    windows_x64 {
       architecture "x86_64"
       operatingSystem "windows"
    }
  }

  toolChains {
    gcc(Gcc) 
  }

  repositories {
    libs(PrebuiltLibraries) {
      geosupport {
        headers.srcDir gsIncludePath
        binaries.withType(SharedLibraryBinary) {
          if (targetPlatform.operatingSystem.windows) {
        logger.lifecycle("geosupport ${targetPlatform.operatingSystem.toString()}")
            // Typically, Visual C++ uses both a .dll and a .lib file for linking.
            // Does this apply to MSYS2/mingw64, Cygwin or MinGW?
            sharedLibraryFile = file("${gsLibraryPath}/NYCgeo.dll")
            sharedLibraryLinkFile = file("${gsLibraryPath}/NYCgeo.lib")
          } else if (targetPlatform.operatingSystem.linux) {
        logger.lifecycle("geosupport ${targetPlatform.operatingSystem.toString()}")
            sharedLibraryFile = file("${gsLibraryPath}/libgeo.so")
          }
        }
      }

      jni_jdk {
        binaries.withType(SharedLibraryBinary) {
          def os = targetPlatform.operatingSystem
          if (os.windows) {
logger.lifecycle("jni_jdk ${os}")
            headers.srcDirs "${jniJavaHome}/include", "${jniJavaHome}/include/win32"
          } else if (os.linux) {
logger.lifecycle("jni_jdk: ${os}")
            headers.srcDirs "${jniJavaHome}/include", "${jniJavaHome}/include/linux"
          }
        }
      }
    }
  } // repositories

} // model

model {
  binaries { modelMap ->
    withType(NativeLibraryBinarySpec) {
      if (toolChain in Gcc) {
        cCompiler.args "-o0", "-g3", "-Wall", "-std=c99"
        if (targetPlatform.operatingSystem.windows) {
          cCompiler.define "DLL_EXPORT"
          linker.args "-shared", "-L${gsLibraryPath}", "-Wl,--add-stdcall-alias", "-lm", "-lNYCgeo", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        } else if (targetPlatform.operatingSystem.linux) {
          cCompiler.args "-fPIC"
          linker.args "-L${gsLibraryPath}", "-lc", "-lm", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        }
      }
    }
    withType(NativeExecutableBinarySpec) {
      if (toolChain in Gcc) {
        cCompiler.args "-o0", "-g3", "-Wall", "-std=c99"
        if (targetPlatform.operatingSystem.windows) {
          cCompiler.define "DLL_IMPORT"
          linker.args "-L${gsLibraryPath}", "-lm", "-lNYCgeo", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        } else if (targetPlatform.operatingSystem.linux) {
          linker.args "-L${gsLibraryPath}", "-lc", "-lm", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        }
      }
    }
  }
} // model

model {
  components {
    geoclient(NativeLibrarySpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      sources {
        c {
          source {
            srcDir "src/main/c"
            include "**/*.c"
          }
          exportedHeaders {
            srcDir "src/main/headers"
            include "**/*.h"
          }
          lib library: 'geosupport', linkage: 'api'
        }
      } // sources
    } // geoclient

    geoclientTest(NativeExecutableSpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      baseName "geoclient_test"
      sources {
        c {
          source {
            srcDir "src/test/c"
            include "**/*.c"
          }
          exportedHeaders {
            srcDir "src/test/headers"
            include "**/*.h"
          }
          lib library: 'geosupport', linkage: 'api'
          lib library: 'geoclient', linkage: 'static'
        }
      } // sources
    } // geoclientTest

    geoclientJni(NativeLibrarySpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      baseName "geoclient_jni"
      sources {
        c {
          source {
            srcDir "src/generated/c"
            include "**/*.c"
          }
          // Even though the generated JNI C code only depends on geoclient.h,
          // the Gluegen code generation process fails without this dependency
          // because Gluegen does not evaluate C macros. Since geoclient.h
          // includes geo.h (and NYCgeo.h on Windows) if these files are not on
          // the include path, Gluegen bails despite gluegen.cfg directives to
          // explicitly ignore libgeo API functions
          lib library: 'geosupport', linkage: 'api' // still needed by gluegen?
          lib library: 'jni_jdk',    linkage: 'api'
          lib library: 'geoclient',  linkage: 'static'
        }
      } // sources
    } // geoclient_jni
  } // components

  tasks {
    syncLocalNativeLibs(Sync) {
      description 'Sync native binaries to $localLibsDir for use by integration tests.'
      def bins = $.binaries.withType(NativeLibraryBinarySpec).findAll { it.buildable }
      bins << $.binaries.withType(NativeExecutableBinarySpec).findAll { it.buildable }
      from bins.collect { it.primaryOutput }
      destinationDir = file(rootProject.localLibsDir)
    }
    build.finalizedBy(syncLocalNativeLibs)
  } // tasks 
} // model
