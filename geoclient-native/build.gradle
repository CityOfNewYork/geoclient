apply plugin: 'c'
apply plugin: 'ivy-publish'

model {
  platforms {
    linux_x64 {
       architecture "x86_64"
       operatingSystem "linux"
    }
    windows_x64 {
       architecture "x86_64"
       operatingSystem "windows"
    }
  }

  toolChains {
    gcc(Gcc) {
      eachPlatform { 
        if (platform.operatingSystem == "windows" && platform.architecture == "x86_64") {
          path "${gccWinX64Path}"
        }
      }
    }
  }

  repositories {
    libs(PrebuiltLibraries) {
      geosupport {
        headers.srcDir gsIncludePath
        binaries.withType(SharedLibraryBinary) {
          if (targetPlatform.operatingSystem.windows) {
            // Visual C++ uses a .dll file with a different .lib file for linking 
            // (This does not apply to Cygwin or MinGW)
            sharedLibraryFile = file("${gsLibraryPath}/NYCgeo.dll")
            sharedLibraryLinkFile = file("${gsLibraryPath}/NYCgeo.lib")
          } else {
            sharedLibraryFile = file("${gsLibraryPath}/libgeo.so")
          }
        }
      }

      jni_jdk {
        binaries.withType(NativeBinary) {
          if (targetPlatform.operatingSystem.windows) {
            headers.srcDirs "${jniJavaHome}/include", "${jniJavaHome}/include/win32"
            binaries.withType(StaticLibraryBinary) {
              staticLibraryFile = file("${jniJavaHome}/lib/jvm.lib")
            }
          } else {
            headers.srcDirs "${jniJavaHome}/include", "${jniJavaHome}/include/linux"
          }
        }
      }
    }
  } // repositories
  
  //gluegen {
  //  header file("src/main/headers/geoclient.h")
  //  resourcesDir file("${rootDir}/geoclient-generate/src/main/resources")
  //  gluegenClasspath project.gluegenClasspath
  //  gluegenFileName "gluegen.cfg"
  //  includePath project.gsIncludePath
  //  javaExe "${project.jniJavaHome}/bin/java"
  //  workingDir file("${buildDir}/gluegen")
  //  generatedSource {
  //    nativeFileName "GeoclientImpl_JNI.c"
  //    targetNativeFileName "geoclient_jni.c"
  //    nativeOutputDir file("${buildDir}/src/generated/c")
  //    javaOutputDir file("${buildDir}/src/generated/java")
  //  }
  //}

  binaries { modelMap ->
    withType(NativeBinary) {
      if (toolChain in Gcc) {
        // TODO should be able to remove '-fPIC' from compiler arguments since
        // it's for building shared libraries and gcc passes it through to
        // the linker (ld)
        cCompiler.args  "-fPIC", "-o0", "-g3", "-Wall", "-std=c99"
      }
    }
    withType(NativeLibraryBinarySpec) {
      if (toolChain in Gcc) {
        if (targetPlatform.operatingSystem.windows) {
          linker.args "-shared", "-L${gsLibraryPath}", "-Wl,--add-stdcall-alias", "-lm", "-lNYCgeo", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        } else {
          linker.args "-fPIC", "-L${gsLibraryPath}", "-lc", "-lm", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        }
      }
    }
    withType(NativeExecutableBinarySpec) {
      if (toolChain in Gcc) {
        if (targetPlatform.operatingSystem.windows) {
          linker.args "-L${gsLibraryPath}", "-Wl,--add-stdcall-alias", "-lm", "-lNYCgeo", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        } else {
          linker.args "-L${gsLibraryPath}", "-lc", "-lm", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        }
      }
    }
  }
} // model

model {
  components {
    geoclient(NativeLibrarySpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      sources {
        c {
          source {
            srcDir "src/main/c"
            include "**/*.c"
          }
          exportedHeaders {
            srcDir "src/main/headers"
            include "**/*.h"
          }
          lib library: 'geosupport', linkage: 'api'
        }
      }
    }

    geoclientTest(NativeExecutableSpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      baseName "geoclient_test"
      sources {
        c {
          source {
            srcDir "src/test/c"
            include "**/*.c"
          }
          exportedHeaders {
            srcDir "src/test/headers"
            include "**/*.h"
          }
          lib library: 'geosupport', linkage: 'api'
          lib library: 'geoclient', linkage: 'static'
        }
      }
    }

    geoclientJni(NativeLibrarySpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      baseName "geoclient_jni"
      sources {
        gluegenOutput(CSourceSet) {
          generatedBy tasks.generateJni
          source {
            include "**/*.c"
          }
        }
        c.lib sources.gluegenOutput
        //c.source {
        //    srcDir "src/generated/c"
        //    include "**/*.c"
        //}
        // Even though the generated JNI C code only depends on geoclient.h,
        // the Gluegen code generation process fails without this dependency
        // because Gluegen does not evaluate C macros. Since geoclient.h
        // includes geo.h (and NYCgeo.h on Windows) if these files are not on
        // the include path, Gluegen bails despite gluegen.cfg directives to
        // explicitly ignore libgeo API functions
        c.lib library: 'geosupport', linkage: 'api' 
        c.lib library: 'geoclient', linkage: 'static'
        c.lib library: 'jni_jdk', linkage: 'api'
      }
    } // geoclient_jni

  } // components

  publishing {
    publications {
      ivyLocal(IvyPublication) {
        // TODO does not work:
        // [$("components.geoclient"), $("components.geoclientJni")].each { c ->
        //   c.binaries { binaries ->
        $("components.geoclientJni").binaries { binaries ->
          binaries.values().each { binary ->
            if (binary.buildable) {
              def pubSpec = new NativePublicationSpec(binary)
              module = pubSpec.name
              organisation = project.group
              revision = project.version
              status = project.status
              //println "name: $pubSpec.name type: $pubSpec.type classifier: $pubSpec.classifier"
              artifact pubSpec
            }
          }
        }
        // }
      }
    }
    repositories.ivyNative
  }

} // model

@groovy.transform.Canonical
class NativePublicationSpec implements PublishArtifact {
  Date date
  String name
  String classifier
  String type
  String extension
  File file
  TaskDependency buildDependencies
  NativePublicationSpec() {}
  NativePublicationSpec(NativeBinarySpec binary) {
    this.name = binary.component.name
    this.classifier = binary.targetPlatform.name
    this.type = binary.name.endsWith("SharedLibrary") ? "sharedLibrary" : "staticLibrary"
    this.file = binary.primaryOutput
    java.nio.file.Path primaryFile = binary.primaryOutput.toPath()
    String p = primaryFile.fileName as String
    this.extension = p.substring((p.lastIndexOf(".") + 1), p.size())
    this.buildDependencies = binary.buildDependencies
    //println this
  }

  String publicationName(boolean capitalize = true) {
    def capAndCamel = { s, cap ->
      String result = s.replaceAll(/(_)(\w)/) { all, uscore, c -> c.toUpperCase() }
      cap ? result.capitalize() : result
    }
    "${capAndCamel(this.name, capitalize)}${capAndCamel(this.classifier, true)}${capAndCamel(this.type, true)}"
  }

  String grokExtension(NativeBinarySpec binary) {
    // FIXME this is ridiculous
    if (binary instanceof NativeExecutableBinarySpec) { //&& binary.targetPlatform.operatingSystem == "windows") {
      return "exe"
    }
    java.nio.file.Path primaryFile = binary.primaryOutput.toPath()
    String p = primaryFile.fileName as String
    p.substring((p.lastIndexOf(".") + 1), p.size())
  }

}
