apply plugin: 'c'

def generatedSrcDir = "$projectDir/src/generated/c"

// Run 'cleanGenerateNativeSource' task to remove the generated
// 'src/generated/c/geoclient_jni.c' code
task generateNativeSource(type: Sync) {
  from project(':geoclient-generate').generateNativeSource
  into generatedSrcDir
  ext.headerDir = null
  ext.sourceDir = generatedSrcDir
}

task cleanGeneratedSource

model {
  platforms {
    linux_x64 {
       architecture "x86_64"
       operatingSystem "linux"
    }
    windows_x64 {
       architecture "x86_64"
       operatingSystem "windows"
    }
  }

  toolChains {
    gcc(Gcc) 
  }

  repositories {
    libs(PrebuiltLibraries) {
      geosupport {
        headers.srcDir gsIncludePath
        binaries.withType(SharedLibraryBinary) {
          if (targetPlatform.operatingSystem.windows) {
            sharedLibraryFile = file("${gsLibraryPath}/NYCgeo.dll")
            sharedLibraryLinkFile = file("${gsLibraryPath}/NYCgeo.lib")
          } else if (targetPlatform.operatingSystem.linux) {
            sharedLibraryFile = file("${gsLibraryPath}/libgeo.so")
          }
        }
      }

      jni_jdk {
        // The stored reference to the 'headers' object visible in this closure
        // scope is a workaround to deal with an issue caused by the need for
        // platform-specific header files in a PrebuildLibrary. The 'headers'
        // container does not have visibility into whether the current 
        // targetPlatform is 'buildable'.
        // This fix works for guessable yet unknown reasons when using
        // Gradle v2.14, JDK 1.8.0_92-x86_64, MSYS2/mingw64 on Windows 7, but
        // should be considered suspect.
        //
        // See: https://discuss.gradle.org/t/native-prebuilt-library-platform-specific-headers/17418
        //
        headers.srcDir "${jniJavaHome}/include"
        def headersContainer = headers
        binaries.withType(SharedLibraryBinary) {
          def os = targetPlatform.operatingSystem
          if (os.windows) {
            headersContainer.srcDir "${jniJavaHome}/include/win32"
          } else if (os.linux) {
            headersContainer.srcDir "${jniJavaHome}/include/linux"
          }
        }
      }
    }
  } // repositories

} // model

model {
  binaries { modelMap ->
    withType(NativeLibraryBinarySpec) {
      if (toolChain in Gcc) {
        cCompiler.args "-o0", "-g3", "-Wall", "-std=c99"
        if (targetPlatform.operatingSystem.windows) {
          cCompiler.define "DLL_EXPORT"
          linker.args "-shared", "-L${gsLibraryPath}", "-Wl,--add-stdcall-alias", "-lm", "-lNYCgeo", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        } else if (targetPlatform.operatingSystem.linux) {
          cCompiler.args "-fPIC"
          linker.args "-Wl,--no-as-needed", "-L${gsLibraryPath}", "-lc", "-lgeo", "-lm", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        }
      }
    }
    withType(NativeExecutableBinarySpec) {
      if (toolChain in Gcc) {
        cCompiler.args "-o0", "-g3", "-Wall", "-std=c99"
        if (targetPlatform.operatingSystem.windows) {
          cCompiler.define "DLL_IMPORT"
          linker.args "-L${gsLibraryPath}", "-lm", "-lNYCgeo", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        } else if (targetPlatform.operatingSystem.linux) {
          linker.args "-Wl,--no-as-needed", "-L${gsLibraryPath}", "-lc", "-lgeo", "-lm", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        }
      }
    }
  }
} // model

model {
  components {
    geoclient(NativeLibrarySpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      sources {
        c {
          source {
            srcDir "src/main/c"
            include "**/*.c"
          }
          exportedHeaders {
            srcDir "src/main/headers"
            include "**/*.h"
          }
          lib library: 'geosupport', linkage: 'api'
        }
      } // sources
    } // geoclient

    geoclientTest(NativeExecutableSpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      baseName "geoclient_test"
      sources {
        c {
          source {
            srcDir "src/test/c"
            include "**/*.c"
          }
          exportedHeaders {
            srcDir "src/test/headers"
            include "**/*.h"
          }
          lib library: 'geosupport', linkage: 'api'
          lib library: 'geoclient', linkage: 'static'
        }
      } // sources
    } // geoclientTest

    geoclientJni(NativeLibrarySpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      baseName "geoclient_jni"
      sources {
        c {
          source {
            srcDir generatedSrcDir
            include "**/*.c"
            generatedBy(generateNativeSource)
          }
          // Even though the generated JNI C code only depends on geoclient.h,
          // the Gluegen code generation process fails without this dependency
          // because Gluegen does not evaluate C macros. Since geoclient.h
          // includes geo.h (and NYCgeo.h on Windows) if these files are not on
          // the include path, Gluegen bails despite gluegen.cfg directives to
          // explicitly ignore libgeo API functions
          lib library: 'geosupport', linkage: 'api' // still needed by gluegen?
          lib library: 'jni_jdk',    linkage: 'api'
          lib library: 'geoclient',  linkage: 'static'
        }
      } // sources

    } // geoclient_jni
  } // components

  tasks {
    syncLocalNativeLibs(Sync) {
      description 'Sync native binaries to $localLibsDir for use by integration tests.'
      def bins = $.binaries.withType(NativeLibraryBinarySpec).findAll { it.buildable }
      bins << $.binaries.withType(NativeExecutableBinarySpec).findAll { it.buildable }
      from bins.collect { 
        it.primaryOutput
      }
      //from(files(project.gsLibraryPath))
      destinationDir = file(rootProject.localLibsDir)
    }
    nativeDist(Zip) {
      from syncLocalNativeLibs
      baseName = project.name
      destinationDir = file(rootProject.buildDir)
    }
    build.finalizedBy(syncLocalNativeLibs)

  } // tasks 
} // model

//apply from: "${gradleScriptDir}/publish-maven.gradle"
//publishing {
//  publications {
//    mavenJava {
//      artifact distNative {
//        classifier "native"
//      }
//    }
//  }
//}
