apply plugin: 'c'

configurations {
  archives
}

task jar(type: org.gradle.api.tasks.bundling.Jar) {
  //dependsOn assemble
  manifest {
    attributes(
      'Specification-Title': project.name,
      'Specification-Version': project.version,
      'Specification-Vendor': 'City of NYC/DoITT/Citywide GIS',
      'Implementation-Title': project.name,
      'Implementation-Version': project.version,
      'Implementation-Vendor': 'City of NYC/DoITT/Citywide GIS',
      'Built-By': System.getProperty('user.name'),
      'Built-Date': new Date(),
      'Built-Gradle': gradle.gradleVersion
    )
  }
  //archiveName = ${baseName}-${appendix}-${version}-${classifier}.${extension}
  //def bins = $.binaries.withType(NativeLibraryBinarySpec).findAll { it.buildable }
  //from bins.collect {
  //  it.primaryOutput
  //}
  //include '**/libgeoclientjni.so'
  //rename 'libgeoclientjni.so', 'libgeoclientjni-linux64.so'
  ext.bins = fileTree(dir: "$buildDir/libs", includes: ["**/libgeoclientjni.so"])
  include '**/libgeoclientjni.so'
  rename 'libgeoclientjni.so', 'libgeoclientjni-linux64.so'
}
artifacts {
  archives jar
}

task nativeZip(type: Zip, dependsOn: build) {
  version = project.version
  from file("$buildDir/libs")
}

task zipWindows64Bins(type: Zip, dependsOn: assemble) {
  ext.bins = fileTree(dir: "$buildDir/libs", includes: ["**/windows_x64/*"])
  classifier = 'windows_x64'
  version = project.version
  from bins.files
}

task zipLinux64Bins(type: Zip, dependsOn: assemble) {
  ext.bins = fileTree(dir: "$buildDir/libs", includes: ["**/linux_x64/*"])
  classifier = 'linux_x64'
  version = project.version
  from bins.files
}

model {
  platforms {
    linux_x64 {
       architecture "x86_64"
       operatingSystem "linux"
    }
    windows_x64 {
       architecture "x86_64"
       operatingSystem "windows"
    }
  }

  toolChains {
    gcc(Gcc)
  }

  repositories {
    libs(PrebuiltLibraries) {
      geosupport {
        headers.srcDir(gsIncludePath ?: "${projectDir}/src/geosupport/headers")
        binaries.withType(SharedLibraryBinary) {
          if (targetPlatform.operatingSystem.windows) {
            sharedLibraryFile = file("${gsLibraryPath}/NYCgeo.dll")
            sharedLibraryLinkFile = file("${gsLibraryPath}/NYCgeo.lib")
          } else if (targetPlatform.operatingSystem.linux) {
            sharedLibraryFile = file("${gsLibraryPath}/libgeo.so")
          }
        }
      }

      jni_jdk {
        // The stored reference to the 'headers' object visible in this closure
        // scope is a workaround to deal with an issue caused by the need for
        // platform-specific header files in a PrebuiltLibrary. The 'headers'
        // container does not have visibility into whether the current
        // targetPlatform is 'buildable'.
        // This fix works for guessable yet unknown reasons when using
        // Gradle v2.14, JDK 1.8.0_92-x86_64, MSYS2/mingw64 on Windows 7, but
        // should be considered suspect.
        //
        // See: https://discuss.gradle.org/t/native-prebuilt-library-platform-specific-headers/17418
        //
        headers.srcDir "${jniJavaHome}/include"
        def headersContainer = headers
        binaries.withType(SharedLibraryBinary) {
          def os = targetPlatform.operatingSystem
          if (os.windows) {
            headersContainer.srcDir "${jniJavaHome}/include/win32"
          } else if (os.linux) {
            headersContainer.srcDir "${jniJavaHome}/include/linux"
          }
        }
      }
    }
  } // repositories

} // model

model {
  binaries { modelMap ->
    withType(NativeLibraryBinarySpec) {
      if (toolChain in Gcc) {
        cCompiler.args "-o0", "-g3", "-Wall", "-std=c99"
        if (targetPlatform.operatingSystem.windows) {
          cCompiler.define "DLL_EXPORT"
          linker.args "-shared", "-L${gsLibraryPath}", "-Wl,--add-stdcall-alias", "-lm", "-lNYCgeo", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        } else if (targetPlatform.operatingSystem.linux) {
          cCompiler.args "-fPIC"
          linker.args "-Wl,--no-as-needed", "-L${gsLibraryPath}", "-lc", "-lgeo", "-lm", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        }
      }
    }
    withType(NativeExecutableBinarySpec) {
      if (toolChain in Gcc) {
        cCompiler.args "-o0", "-g3", "-Wall", "-std=c99"
        if (targetPlatform.operatingSystem.windows) {
          cCompiler.define "DLL_IMPORT"
          linker.args "-L${gsLibraryPath}", "-lm", "-lNYCgeo", "-lgeo", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        } else if (targetPlatform.operatingSystem.linux) {
          linker.args "-Wl,--no-as-needed", "-L${gsLibraryPath}", "-lc", "-lgeo", "-lm", "-ledequiv", "-lapequiv", "-lsan", "-lsnd", "-lstExcpt", "-lStdLast", "-lStdUniv", "-lstEnder", "-lstretch", "-lthined"
        }
      }
    }
  }
} // model

model {
  components {
    geoclient(NativeLibrarySpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      sources {
        c {
          source {
            srcDir "src/main/c"
            include "**/*.c"
          }
          exportedHeaders {
            srcDir "src/main/headers"
            include "**/*.h"
          }
          lib library: 'geosupport', linkage: 'api'
        }
      } // sources
    } // geoclient

    geoclientTest(NativeExecutableSpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      baseName "geoclient_test"
      sources {
        c {
          source {
            srcDir "src/test/c"
            include "**/*.c"
          }
          exportedHeaders {
            srcDir "src/test/headers"
            include "**/*.h"
          }
          lib library: 'geosupport', linkage: 'api'
          lib library: 'geoclient', linkage: 'static'
        }
      } // sources
    } // geoclientTest

    geoclientJni(NativeLibrarySpec) {
      targetPlatform "linux_x64"
      targetPlatform "windows_x64"
      baseName "geoclientjni"
      sources {
        c {
          source {
            srcDir "$projectDir/src/generated/c"
            include "**/*.c"
          }
          // Even though the generated JNI C code only depends on geoclient.h,
          // the Gluegen code generation process fails without this dependency
          // because Gluegen does not evaluate C macros. Since geoclient.h
          // includes geo.h (and NYCgeo.h on Windows) if these files are not on
          // the include path, Gluegen bails despite gluegen.cfg directives to
          // explicitly ignore libgeo API functions
          lib library: 'geosupport', linkage: 'api' // still needed by gluegen?
          lib library: 'jni_jdk',    linkage: 'api'
          lib library: 'geoclient',  linkage: 'static'
        }
      } // sources

    } // geoclientjni
  } // components

  tasks {

    syncLocalNativeLibs(Sync) {
      description 'Sync native binaries to $localLibsDir for use by integration tests.'
      def bins = $.binaries.withType(NativeLibraryBinarySpec).findAll { it.buildable }
      bins << $.binaries.withType(NativeExecutableBinarySpec).findAll { it.buildable }
      from bins.collect {
        it.primaryOutput
      }
      destinationDir = file(rootProject.localLibsDir)
    }
    //build.finalizedBy(syncLocalNativeLibs)
    assemble.finalizedBy(syncLocalNativeLibs)
    assemble.finalizedBy(jar)

  } // tasks

} // model
