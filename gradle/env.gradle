import java.nio.file.Paths
import java.nio.file.Files
import org.apache.tools.ant.taskdefs.condition.Os

ext {

  // Runtime location of libgeoclientjni.so or geoclientjni.dll
  //   * In project geoclient-jni, GeoclientImpl passes the value of
  //     System.properties['java.io.tmpdir'] to the NativeLibraryLoader class 
  //   * GeoclientImpl is generated by Gluegen in project geoclient-generate
  //   * Note that token replacement using this property in the geoclient.cfg
  //     file in geoclient-generate is not recommended because it should be 
  //     dynamic at runtime. This property is meant for build time testing
  gcLibraryPath = System.properties['java.io.tmpdir']

  // Directory containing Geosupport data files:
  //   * Defaults to null
  //   * Can be set on command line: -PgsGeofiles=...
  //   * Otherwise, the value of environment variable GEOFILES is used if set
  gsGeofiles = resolveProperty('gsGeofiles', 'GEOFILES')

  // Directory containing Geosupport C header files:
  //   * Defaults to ${rootDir}/geoclient-native/src/geosupport/headers
  //   * Can be set on command line: -PgsIncludePath=...
  //   * Otherwise, the value of environment variable GS_INCLUDE_PATH is used 
  //     if set
  gsIncludePath = resolveProperty('gsIncludePath', 'GS_INCLUDE_PATH',
                  "${project(':geoclient-native').projectDir}/src/geosupport/headers")

  // Directory containing Geosupport C library binaries and link libs:
  //   * Defaults to null
  //   * Can be set on command line: -PgsLibraryPath=...
  //   * Otherwise, the value of environment variable GS_LIBRARY_PATH is used
  //     if set
  gsLibraryPath = resolveProperty('gsLibraryPath', 'GS_LIBRARY_PATH')

  // Top-level path to full JDK's include and platform-specific sub-directories
  // for JNI headers:
  //   * Defaults to environment variable JAVA_HOME
  //   * Can be set on command line: -PjniJavaHome=...
  //   * Otherwise, the value of environment variable JNI_JAVA_HOME is used
  //     if set
  jniJavaHome = resolveProperty('jniJavaHome', 'JNI_JAVA_HOME', System.env['JAVA_HOME'])

  localLibsDir="${rootProject.buildDir}/libs"

  // Environment variable name used to tweak the native system library path
  //   * Linux: LD_LIBRARY_PATH
  //   * Win64: PATH
  libraryPathEnvironmentVariableName = Os.isFamily(Os.FAMILY_WINDOWS) ? 'PATH' : 'LD_LIBRARY_PATH'

}

// Adapted from gradle-docker-plugin project file: gradle/publishing.gradle
String resolveProperty(String projectPropKey, String envVarKey, String defaultValue=null) {

  String result = null

  // Give Gradle command-line/project properties precedence
  if(hasProperty(projectPropKey)) {
    return getProperty(projectPropKey)
  }

  if(hasProperty("geoclient.${projectPropKey}")) {
    return getProperty("geoclient.${projectPropKey}")
  }

  String envValue = System.getenv()[envVarKey]

  if(envValue) {
    return envValue
  }

  return defaultValue

}

task runtimeReport {
  doFirst {
    def hlog = { heading ->
      logger.lifecycle("\n${heading}")
      logger.lifecycle("---------------------------------------------------")
    }
    def plog = { cat, k, v ->
      logger.lifecycle("[$cat] $k='$v'")
    }

    hlog("JAVA SYSTEM PROPERTIES")
    def ps = System.properties
    plog("SYSPROP", "user.home",           ps["user.home"])
    plog("SYSPROP", "user.dir",            ps["user.dir"])
    plog("SYSPROP", "java.io.tmpdir",      ps["java.io.tmpdir"])
    plog("SYSPROP", "java.library.path",   ps["java.library.path"])
    plog("SYSPROP", "os.name",             ps["os.name"])

    hlog("\nENVIRONMENT VARIABLES")
    def ev = System.getenv()
    plog("ENV",     "GEOFILES",            ev["GEOFILES"])
    plog("ENV",     "GC_LIBRARY_PATH",     ev["GC_LIBRARY_PATH"])
    plog("ENV",     "GS_INCLUDE_PATH",     ev["GS_INCLUDE_PATH"])
    plog("ENV",     "GS_LIBRARY_PATH",     ev["GS_LIBRARY_PATH"])
    plog("ENV",     "JAVA_HOME",           ev["JAVA_HOME"])
    plog("ENV",     "JNI_JAVA_HOME",       ev["JNI_JAVA_HOME"])
    plog("ENV",     "LD_LIBRARY_PATH",     ev["LD_LIBRARY_PATH"])
    plog("ENV",     "PATH",                ev["PATH"])

    hlog("\nNATIVE PROPERTIES")
    plog("NATIVE",  "gsGeofiles",          gsGeofiles)
    plog("NATIVE",  "gsIncludePath",       gsIncludePath)
    plog("NATIVE",  "gsLibraryPath",       gsLibraryPath)
    plog("NATIVE",  "jniJavaHome",         jniJavaHome)
    plog("NATIVE",  "libraryPathEnvironmentVariableName", libraryPathEnvironmentVariableName)

  }
}

tasks.addRule("Pattern: lspath<ID>") { String taskName ->
  if (taskName.startsWith("lspath")) {
    task(taskName) << {
      String prop = taskName - 'lspath'
      String value = resolveProperty(prop, prop)
      if(prop && value) {
        def pathsep = System.properties['path.separator']
        logger.lifecycle("\npath.separator='${pathsep}'")
        logger.lifecycle("\n${prop}")
        logger.lifecycle("---------------------------------------------------")
        value.split(pathsep).each { line ->
          java.nio.file.Path p = Paths.get(line)
          String status = Files.exists(p) ? "" : "\t(missing)"
          logger.lifecycle("\t${line}${status}")
        }
      } else {
        logger.warn("\nPath property '${prop}' is empty or null")
      }
    }
  }
}