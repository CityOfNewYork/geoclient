apply from: "${rootDir}/gradle/dependencies.gradle"

allprojects {
    apply plugin: 'eclipse'
    apply plugin: 'project-report'
    apply plugin: 'gov.nyc.doitt.gis.geoclient.gradle.geoclient-plugin'
    //'gov.nyc.doitt.gis.geoclient.gradle.GeoclientPlugin'

    geosupport {
        home = "${System.getenv('GEOSUPPORT_HOME')}"
        libraryPath = "${System.getenv('GEOSUPPORT_HOME')}/lib"
        geofiles = "${System.getenv('GEOFILES')}"
    }
}

subprojects {

    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'signing'

    repositories {
        maven { url "http://maven.geotoolkit.org/" }
        mavenCentral()
        maven { url "http://repo.boundlessgeo.com/main/" }
    }

    dependencies {
        implementation enforcedPlatform('org.springframework.boot:spring-boot-dependencies:2.1.1.RELEASE')
        implementation 'org.springframework.boot:spring-boot-starter-logging'
        testImplementation('org.springframework.boot:spring-boot-starter-test') {
            exclude group: 'org.junit', module: 'junit'
        }
        testImplementation 'org.junit.jupiter:junit-jupiter-api'
        testImplementation 'org.junit.jupiter:junit-jupiter-params'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
    }

    def commonCompilerArgs =
            ["-Xlint:serial", "-Xlint:cast", "-Xlint:classfile", "-Xlint:dep-ann",
             "-Xlint:divzero", "-Xlint:empty", "-Xlint:finally", "-Xlint:overrides",
             "-Xlint:path", "-Xlint:processing", "-Xlint:static", "-Xlint:try", "-Xlint:-options"]

    compileJava.options*.compilerArgs = commonCompilerArgs +
            ["-Xlint:varargs", "-Xlint:fallthrough", "-Xlint:rawtypes",
             "-Xlint:deprecation", "-Xlint:unchecked", "-Werror"]

    compileTestJava.options*.compilerArgs = commonCompilerArgs +
            ["-Xlint:-varargs", "-Xlint:-fallthrough", "-Xlint:-rawtypes",
             "-Xlint:-deprecation", "-Xlint:-unchecked"]

    compileJava {
        sourceCompatibility = 1.8
        targetCompatibility = 1.8
        options.encoding = 'UTF-8'
    }

    compileTestJava {
        sourceCompatibility = 1.8
        targetCompatibility = 1.8
        options.encoding = 'UTF-8'
    }

    ext {
        //enableJavadoc = getConfigProperty('nojdoc') ? false : true
enableJavadoc = false
        //gcJniVersion = getJniVersion()
gcJniVersion = 'geoclient-jni-2.0'
        gsIncludePath = new File(projectDir, 'lib/geosupport/headers')
        //gsLibraryPath = getGeosupportLibraryDir()
        //gsGeofiles = getGeofiles()
def geosupportHome = System.getenv('GEOSUPPORT_HOME')
gsLibraryPath = new File("${geosupportHome}/lib")
gsGeofiles = new File("${geosupportHome}/fls")
        localLibsDir = new File(rootProject.buildDir, 'libs')
    }

    test {
        useJUnitPlatform()
        systemProperty 'gc.jni.version', gcJniVersion
        systemProperty 'java.library.path', gsLibraryPath
        // Ensure Geosupport knows where to find its data files
        environment 'GEOFILES', gsGeofiles
        testLogging.showStandardStreams = true
    }
    
    javadoc {
        options {
            memberLevel = JavadocMemberLevel.PROTECTED
            author = true
            header = project.name
            use = true
            //encoding = 'UTF-8'
            noTimestamp = true
        }
    }

    tasks.withType(Javadoc).all { enabled = project.ext.enableJavadoc }

    jar {
        manifest {
            attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'Built-By': System.getProperty('user.name'),
                'Built-JDK': System.getProperty('java.version'),
                'Built-Gradle': gradle.gradleVersion
            )
        }

        from("${rootProject.projectDir}/src/dist") {
            include 'LICENSE.txt'
            include 'NOTICE.txt'
            into 'META-INF'
            expand(copyright: new Date().format('yyyy'), version: project.version)
        }
    }

    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    task javadocJar(type: Jar) {
        classifier = 'javadoc'
        from javadoc
    }

    artifacts {
        archives sourcesJar
        archives javadocJar
    }

    publishing {
        repositories {
            maven {
                name = 'localBuild'
                url = "file://${rootProject.buildDir}/repo"
            }
        }
        publications {
            mavenJava(MavenPublication) {
                from components.java
                artifact sourcesJar
                artifact javadocJar
                pom {
                    name = project.name
                    description = project.description
                    url = 'https://github.com/CityOfNewYork/geoclient'
                    inceptionYear = '2013'
                    licenses {
                        license {
                            name = 'The Apache License, Version 2.0'
                            url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                            distribution = 'repo'
                        }
                    }
                    organization {
                        name = 'City of New York / DoITT / Citywide GIS'
                        url = 'https://maps.nyc.gov'
                    }
                    developers {
                        developer {
                            id = 'mlipper'
                            name = 'Matthew Lipper'
                            email = 'mlipper@doitt.nyc.gov'
                        }
                    }
                    scm {
                        connection = 'scm:https://git@github.com/CityOfNewYork/geoclient.git'
                        developerConnection = 'scm:git://github.com/CityOfNewYork/geoclient.git'
                        url = 'https://maps.nyc.gov/geoclient/v1/doc'
                    }

                    issueManagement {
                        system = 'GitHub'
                        url = 'https://github.com/CityOfNewYork/geoclient/issues'
                    }

                } // pom
            } // mavenJava(MavenPublication)
        } //publications
    } // publishing

    signing { sign publishing.publications.mavenJava }

    task showMe {
        doLast() {
            logger.lifecycle("Gradle Properties:")
            logger.lifecycle("      enableJavadoc: ${enableJavadoc}")
            logger.lifecycle("             nojdoc: ${nojdoc}")
            logger.lifecycle("       gcJniVersion: ${gcJniVersion}")
            logger.lifecycle("      gsIncludePath: ${gsIncludePath}")
            logger.lifecycle("      gsLibraryPath: ${gsLibraryPath}")
            logger.lifecycle("         gsGeofiles: ${gsGeofiles}")
            
            logger.lifecycle("Environment:")
            logger.lifecycle("    GEOSUPPORT_HOME: ${System.getenv('GEOSUPPORT_HOME')}")
            logger.lifecycle("           GEOFILES: ${System.getenv('GEOFILES')}")
            logger.lifecycle("    LD_LIBRARY_PATH: ${System.getenv('LD_LIBRARY_PATH')}")
            logger.lifecycle("               PATH: ${System.getenv('PATH')}")
            
            logger.lifecycle("Java SystemProperties:")
            logger.lifecycle("     gc.jni.version: ${System.getProperty('gc.jni.version')}")
            logger.lifecycle("  java.library.path: ${System.getProperty('java.library.path')}")
            logger.lifecycle("     java.io.tmpdir: ${System.getProperty('java.io.tmpdir')}")
        }
    }

} // allprojects

// TODO Put this in buildScript plugin
//File getGeosupportLibraryDir() {
//    def gsLibraryPath = getConfigProperty('gsLibraryPath')
//    if(!gsLibraryPath) {
//        String geosupportHome = getGeosupportHome()
//        return new File("${geosupportHome}/lib")
//    }
//    return new File(gsLibraryPath)
//}
//
//String getGeofiles() {
//    String geofiles = getConfigProperty('gsGeofiles') ?: getEnv('GEOFILES')    
//    if(!geofiles) {
//        String geosupportHome = getGeosupportHome()
//        return new File("${geosupportHome}/fls/")
//    }    
//    if(!geofiles.endsWith('/') && !geofiles.endsWith('\\')) {
//        geofiles += System.getProperty('file.separator')
//    }
//    return geofiles
//}
//
//String getGeosupportHome() {
//    return getConfigProperty('gsHome') ?: getEnv('GEOSUPPORT_HOME')
//}
//
//String getJniVersion() {
//    return getConfigProperty('gcJniVersion')
//}
//
//String getSystemProperty(String name, String defaultValue) {
//    String result = System.getProperty(name, defaultValue)
//    if(result) {
//        logger.info("Configuration '${name}=${result}' resolved from Java system property")
//        return result
//    }
//    logger.info("Java system property '${name}' could not be resolved")
//}
//
//String getEnv(String name) {
//    String result = System.getenv(name)
//    if(result) {
//        logger.info("Configuration '${name}=${result}' resolved from environment variable")
//        return result
//    }
//    logger.info("Environment variable '${name}' could not be resolved")
//}
//
//String getConfigProperty(String key) {
//
//    String result = project.properties.getOrDefault(key, "")
//    if(result) {
//        logger.info("Configuration '${key}=${result}' resolved from Gradle project property")
//        return result
//    }
//
//    result = getSystemProperty(key, "")
//    if(result) {
//        return result
//    }
//    
//    logger.info("Configuration key '${key}' could not be resolved")
//}
